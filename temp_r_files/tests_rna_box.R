# R code with numerical experiments for new paper:
# Optimal allocation in stratified SRSWOR
# under upper and lower bounds for sample strata sizes.

library(dplyr)
library(stratification)
library(microbenchmark)
library(stratallo)

# R codes with algorithms
source("temp_r_files/CapacityScaling.R")
source("temp_r_files/SimpleGreedy.R")
source("temp_r_files/fixedpi.R")

# WW codes
source("temp_r_files/rna_box.R") # new algorithm rna_box
source("temp_r_files/noptcond_sufficient.R")

# auxiliary functions

# random rounding
ran_round <- function(x) {
  return(floor(x) + (runif(length(x)) < (x - floor(x))))
}

# rounding based on article:
# Rama Count, Massoud Heidari, Optimal rounding under integer constraints
# December 2014, arxiv
round_oric <- function(x) {
  n <- round(sum(x))
  m <- floor(x)
  y <- x - m
  Ix <- sum(y)

  if (Ix == 0) {
    return(x)
  } else {
    iy <- order(-y)
    u <- unique(y[iy])
    z <- integer(length(x))
    for (i in 1:length(u)) z[iy] <- z[iy] + (y[iy] == u[i]) * i
    iy2 <- order(-y, z, -m)
    # m[iy][iy2][1:Ix] <- ceiling(x[iy][iy2][1:Ix])
    m[iy2][1:Ix] <- (m[iy2][1:Ix]) + 1
    return(m)
  }
}

# testing new algorithm for many small allocation problems
# parameters generated by sequence of random seeds
testing_alg <- function(seed_from,
                        seed_to,
                        alg = "fixedpi",
                        print_f = FALSE,
                        print_seed = FALSE,
                        print_vertex = FALSE) {

  # generating parameters for allocation problems
  for (seed in seq(seed_from, seed_to)) {
    set.seed(seed)
    if (print_seed) {
      cat("SEED = ", seed, "\n")
    }
    H <- 4 # number of strata
    Nh <- rep(100, H)
    Sh <- round(abs(rcauchy(H, 1)), 1)
    Sh[Sh == 0] <- 1
    # mh <- rep(5,4)
    # Mh <- rep(50,4)
    mh <- rep(10, H)
    Mh <- rep(30, H)

    dh <- Sh * Nh
    # plot(sort(dh),pch=19)
    N <- sum(Nh)
    n_min <- sum(mh) # minimal sample size
    n_max <- sum(Mh) # maximal sample size

    # loop over different sample fractions
    for (f in seq(n_min / N, n_max / N, 0.05)) {
      if (print_f) {
        print(f)
      }
      n <- round(f * N)

      if (n > n_min && n < n_max) {
        # correct integer allocation
        alloc0 <- CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh)

        # condition when solution is at boundaries
        war <- sum((alloc0 == mh) + (alloc0 == Mh)) == length(Nh)
        if (war && print_vertex) {
          cat("Solution at boundaries ! \n")
        }

        if (alg == "fixedpi") {
          nh <- fixedpi(n, Nh, Sh, mh, Mh, lambda0 = NULL, maxiter = 500)$nh
        } else if (alg == "rna_box") {
          nh <- rna_box(n, dh, mh, Mh)
        } else if (alg == "rna_box_perf") {
          nh <- rna_box_perf(n, dh, mh, Mh)
        } else {
          stop("Bad algorithm for comparison !")
        }
        alloc <- round_oric(nh)

        if (any(alloc < mh | alloc > Mh)) {
          cat("alloc0 = ", alloc0, "\n")
          cat("alloc = ", nh, "\n")
          stop("Bad allocation !")
        }

        if (max(abs(alloc - alloc0)) > 1) {
          stop("Difference compared to integer allocation !")
        }
      }
    }
  }
}


testing_alg(1, 1000, alg = "fixedpi")
testing_alg(1, 1000, alg = "rna_box_perf")
testing_alg(1000, 10000, alg = "rna_box_perf")

microbenchmark(
  times = 5,
  unit = "ms",
  alg_fix = testing_alg(60000, 61000, "fixedpi"),
  alg_rna_box_perf = testing_alg(60000, 61000, "rna_box_perf")
)

# comparison for larger populations (large number of strata)

# generation of artificial population, seed for Nrep=100
set.seed(652234)

# seed for Nrep=200
# set.seed(1876)
source("temp_r_files/gen_population.R")
pop <- gen_population(Nrep = 100)
Nh <- pop$Nh
Sh <- pop$Sh
NROW(Nh)
# plot(Nh*Sh)
# hist(Sh*Nh)

# generation of lower and upper bounds
Mh <- Nh * runif(length(Nh))
Mh <- round(pmax(Mh, Nh / 2))
Mh[Mh <= 1] <- 5
# mh<-pmin(2,Mh)
mh <- ceiling(runif(length(Nh)) * Mh / 10) - 1
mh <- pmax(mh, 5)
ix <- which(mh < Mh)
mh <- mh[ix]
Mh <- Mh[ix]
Nh <- Nh[ix]
Sh <- Sh[ix]
which(mh == Mh)
dh <- Sh * Nh
(n_min <- sum(mh)) # minimal sample size
(n_max <- sum(Mh)) # maximal sample size

(N <- sum(Nh)) # population size
NROW(Nh) # number of strata

# variance estimation for given allocation
varal <- function(Nh, Sh, nh) {
  return(sum(Nh * (Nh - nh) * Sh * Sh / nh))
}

tab <- NULL
(n_min <- sum(mh))
(n_max <- sum(Mh))
(N <- sum(Nh))

for (f in seq(n_min / N, n_max / N, 0.05)) {
  print(f)
  N <- sum(Nh)
  n <- round(f * N)

  if (n > n_min && n < n_max) {
    alloc0 <- CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh)
    var_cs <- varal(Nh, Sh, alloc0)

    ix <- which(alloc0 == 1)
    nix <- sum(ix)

    nh_rna <- rna_box_perf(n, Nh * Sh, mh, Mh)
    var_rna <- varal(Nh, Sh, round_oric(nh_rna))

    tabi <- data.frame(
      N = N,
      f = f,
      n = n,
      # rv_noptcond=v_noptcond/V0,
      # rv1_noptcond=v1_noptcond/V0,
      rna_cs_var_ratio = var_rna / var_cs
    )

    tab <- bind_rows(tab, tabi)
  }
}

# saveRDS(tab,"tab.rds")
options(digits = 10)
View(tab)

# time comparison
# creating data with times for selected algorithms and different fractions
tab1 <- NULL
(n_min <- sum(mh))
(n_max <- sum(Mh))
(N <- sum(Nh))
dh <- Sh * Nh

for (f in seq(n_min / N, n_max / N, 0.05)) {
  print(f)
  N <- sum(Nh)
  n <- round(f * N)

  if (n > n_min && n < n_max) {
    alloc0 <- CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh)
    take_min <- sum(alloc0 <= mh)
    take_max <- sum(alloc0 >= Mh)

    al_rna <- round_oric(rna_box_perf(n, dh, mh, Mh))
    if (any(abs(al_rna - alloc0) > 1)) {
      stop("Difference in allocation for rna_box_perf !")
    }

    al_fpi <- round_oric(fixedpi(n, Nh, Sh, mh, Mh)$nh)
    if (any(abs(al_fpi - alloc0) > 1)) {
      stop("Difference in allocation for fixedpi !")
    }

    options(digits = 10)

    ex <- microbenchmark(
      times = 10,
      unit = "ms",
      # CapacityScaling=CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh),
      # noptcond_sufficient = noptcond_sufficient(dh , mh , Mh , n),
      fpi = fixedpi(n, Nh, Sh, mh, Mh)$nh,
      rna_box_perf = rna_box_perf(n, dh, mh, Mh)
    )

    summary(ex)
    exi <- group_by(ex, expr) %>%
      summarise(
        Median_time = median(time) / 1e6, # from nanoseconds to miliseconds
        Mean_time = mean(time) / 1e6
      ) %>%
      mutate(
        N = N,
        f = f,
        H = length(Nh),
        take_min = take_min,
        take_max = take_max
      )

    tab1 <- bind_rows(tab1, exi)
  }
}

View(tab1)
# saveRDS(tab1,"tab1.rds")

### creation of plots
options(digits = 6)

# tab1 <-readRDS("tab1.rds")

tab2 <- mutate(tab1,
  H = as.factor(H),
  algorithm = expr,
  flab = paste0("[", as.character(take_min), ",", as.character(take_max), "]")
)

(xN <- count(tab2, N)$N)
levels(tab2$H) <- paste(
  levels(tab2$H), "strata, N =",
  # sprintf("%f6.1",xN))
  xN
)
round(table(tab2$N))
count(tab2, H)
levels(tab2$algorithm)

tab2 <- tab2 %>%
  mutate(
    Algorithm = relevel(algorithm, c("rna_box_perf"))
  ) %>%
  group_by(Algorithm)

summarise(tab2, mean(Median_time), mean(Mean_time))

library(ggplot2)

p1 <-
  ggplot(tab2, aes(x = f, y = Median_time, shape = Algorithm)) +
  # scale_y_log10() +
  geom_point(size = 2) +
  geom_line(aes(linetype = Algorithm)) +
  facet_wrap(~H, scale = "free") +
  # scale_x_continuous(breaks = seq(0.1,0.9,0.1)) +
  labs(
    x = "sample fraction",
    # y = expression(paste("Time [miliseconds] (", log[10],  " scale)")),
    y = "Time [miliseconds]",
    color = "Algorithms: ",
    title = "Time comparison of selected algorithms"
    # subtitle = "using microbenchmark R package"
  )
p1

# ggsave("fig_times_rna_box_perf.pdf", p1, device="pdf", dpi=600, width = 8, height = 8/1.618)
