# R code with numerical experiments for new paper:
# Optimal allocation in stratified SRSWOR
# under upper and lower bounds for sample strata sizes.


# WW codes
source("R/nopt_box.R") # new algorithm rNa_mm
source("R/noptcond_sufficient.R")


library(dplyr)
library(stratification)
library(microbenchmark)
library(stratallo)

# R codes with algorithms

source("R/CapacityScaling.R")
source("R/SimpleGreedy.R")
source("R/fixedpi.R")



# auxiliary functions

# random rounding
ran_round<-function(x)
{
  return( floor(x)+(runif(length(x))<(x-floor(x))) )
}


# rounding based on article:
# Rama Count, Massoud Heidari, Optimal rounding under integer constraints
# December 2014, arxiv
round_oric <- function(x)
{
  n <- round(sum(x))
  m <- floor(x)
  y <- x - m
  Ix <- sum(y)

  if (Ix==0) return(x)
  else {
    iy <- order(-y)
    u <- unique(y[iy])
    z <- integer(length(x))
    for (i in 1:length(u)) z[iy] <- z[iy] + (y[iy]==u[i])*i
    iy2 <- order(-y,z,-m)
    #m[iy][iy2][1:Ix] <- ceiling(x[iy][iy2][1:Ix])
    m[iy2][1:Ix] <- (m[iy2][1:Ix])+1
    return(m)
  }
  }




testing_alg <- function(seed_from,seed_to,alg="fixedpi",print_f=FALSE)
# testing new algorithm for many small allocation problems
# parameters generated by sequence of random seeds
{
  # generation parameters for allocation problems
  for (seed in seq(seed_from,seed_to)) {
    set.seed(seed)
    cat("SEED = ",seed,"\n")
    H <- 4 # number of strata
    Nh <- rep(100,H)
    Sh <- round(abs(rcauchy(H,1)),1)
    Sh[Sh==0] <- 1
    #mh <- rep(5,4)
    #Mh <- rep(50,4)
    mh <- rep(10,H)
    Mh <- rep(30,H)

    dh <- Sh*Nh
    #plot(sort(dh),pch=19)
    N <- sum(Nh)
    (s1<-sum(mh)) # minimal sample size
    (s2<-sum(Mh)) # maximal sample size

    # loop over different sample fractions
    for (f in seq(s1/N,s2/N,0.05)) {
      if (print_f) print(f)
      n<-round(f*N)

      if (s1<n && n<s2) {

        # correct integer allocation
        alloc0 <- CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh)

        # condition when solution is at boundaries
        war <- sum((alloc0==mh)+(alloc0==Mh))==length(Nh)
        if (war) cat("Solution at boundaries ! \n")

        if (alg=="fixedpi") {
          nh <- fixedpi(n,Nh,Sh, mh, Mh, lambda0=NULL, maxiter=500)$nh
        }
        else if (alg=="rNa_mM") {
          nh <- rNa_mM(dh, mh, Mh, n)
        }
        else {
          stop("Bad algorithm for comparison !")
        }

        al_test <- round_oric(nh)

        if (any(al_test<mh | al_test>Mh) ) {
          stop("Bad allocation !")
        }

        if (max(abs(al_test-alloc0))>1 ) {
          stop("Difference compared to integer allocation !")
        }

      }
    }
  }
}




testing_alg(1,1000,alg="fixedpi",print_f = FALSE)
testing_alg(1,1000,alg="rNa_mM",print_f = FALSE)

testing_alg(1000,10000,alg="rNa_mM",print_f = FALSE)


microbenchmark(times=1,unit="ms",
               alg_fix=testing_alg(60000,61000,"fixedpi"),
               alg_rNa_mM=testing_alg(60000,61000,"rNa_mM")
               )






# comparison for larger populations (large number of strata)

# generation of artificial population
# seed for Nrep=100
set.seed(652234)

# seed for Nrep=200
#set.seed(1876)

source("R/gen_population.R")
pop <- gen_population(Nrep=100)
Nh<-pop$Nh
Sh<-pop$Sh
NROW(Nh)
# plot(Nh*Sh)
# hist(Sh*Nh)


# generation of lower and upper bounds
Mh<-Nh*runif(length(Nh))
Mh<-round(pmax(Mh,Nh/2))
Mh[Mh<=1]<-5
#mh<-pmin(2,Mh)
mh<-ceiling(runif(length(Nh))*Mh/10)-1
mh<-pmax(mh,5)
ix<-which(mh<Mh)
mh<-mh[ix]
Mh<-Mh[ix]
Nh<-Nh[ix]
Sh<-Sh[ix]
which(mh==Mh)
dh<-Sh*Nh
(s1<-sum(mh)) # minimal sample size
(s2<-sum(Mh)) # maximal sample size

(N <- sum(Nh)) # population size
NROW(Nh) # number of strata



# variance comparison for rounding

# variance estimation for given allocation
varal <- function(Nh,Sh,nh)
{
  return( sum(Nh * (Nh - nh) * Sh*Sh / nh) )
}


tab <- NULL
(s1<-sum(mh))
(s2<-sum(Mh))
(N <- sum(Nh))


for (f in seq(s1/N,s2/N,0.05)) {
  print(f)
  N<-sum(Nh)
  n<-round(f*N)

  if (s1<n && n<s2) {

    alc<-CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh)
    V0<-varal(Nh,Sh,alc)

    ix <- which(alc==1)
    nix <- sum(ix)

    nh_rNa <- rNa_mM(Nh*Sh, mh, Mh, n)
    v1_rNa <- varal(Nh,Sh,round_oric(nh_rNa))


    tabi <- data.frame(N=N,f=f,n=n,
                       #rv_noptcond=v_noptcond/V0,
                       #rv1_noptcond=v1_noptcond/V0,
                       rv1_rNa=v1_rNa/V0 # ratio of variances
    )

    tab<-bind_rows(tab,tabi)

  }
}

#saveRDS(tab,"tab.rds")

options(digits=10)
View(tab)





# time comparison
# creating data with times for selected algorithms and different fractions

tab<-NULL

(s1<-sum(mh))
(s2<-sum(Mh))
(N <- sum(Nh))

dh <- Sh*Nh

for (f in seq(s1/N,s2/N,0.05)) {
print(f)
N<-sum(Nh)
n<-round(f*N)

if (s1<n && n<s2) {

alc<-CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh)
h_under <- sum(alc<=mh)  # number of take-all strata
h_over <- sum(alc>=Mh)  # number of take-all strata

al_rNa_mM <- round_oric(rNa_mM(dh, mh, Mh, n))
if (any(abs(al_rNa_mM-alc)>1)) { stop("Difference in allocation for rNa_mM !") }

al_fpi <- round_oric(fixedpi(n,Nh,Sh, mh, Mh)$nh)
if (any(abs(al_fpi-alc)>1)) { stop("Difference in allocation for fixedpi !") }


options(digits=10)

ex<-microbenchmark(times=10,unit="ms",
                   #CapacityScaling=CapacityScaling(n, Nh, Sh, mh = mh, Mh = Mh),
                   #noptcond_sufficient = noptcond_sufficient(dh , mh , Mh , n),
                   fpi=fixedpi(n,Nh,Sh, mh, Mh)$nh,
                   rNa_mM=rNa_mM(dh, mh, Mh, n)
)


summary(ex)



exi<-group_by(ex,expr) %>%
  summarise(Median_time=median(time)/1e6,
            Mean_time=mean(time)/1e6) # from nanoseconds to miliseconds
exi<-mutate(exi,N=N,f=f,H=length(Nh), h_under=h_under,h_over=h_over)


tab<-bind_rows(tab,exi)

}
}

#saveRDS(tab,"tab1.rds")



### creation of plots

options(digits=6)


#tab<-readRDS("tab1.rds")

tab<-mutate(tab,H=as.factor(H),algorithm=expr ,
            flab=paste0("[",as.character(h_under),",",as.character(h_over),"]")
            )

as.vector(table(tab$N))

xN<-count(tab,N)$N

levels(tab$H)<-paste(levels(tab$H),"strata, N =",
                     #sprintf("%f6.1",xN))
                     xN)
round(table(tab$N))
count(tab,H)

levels(tab$algorithm)

tab <- mutate(tab,algorithm=relevel(algorithm,c("rNa_mM")))

group_by(tab,algorithm) %>% summarise(mean(Median_time),mean(Mean_time))


library(ggplot2)

p1<-
  ggplot(data=tab,aes(x=f,y=Median_time, shape=algorithm)) +
  #scale_y_log10() +
  geom_point(size=2) +
  geom_line(data=tab,aes(x=f,y=Median_time,linetype=algorithm)) +
  facet_wrap(~H,scale="free") +
  #scale_x_continuous(breaks = seq(0.1,0.9,0.1)) +
  labs(
       #x=" ",
       x="sample fraction",
       #y = expression(paste("Time [miliseconds] (", log[10],  " scale)")),
       y="Time [miliseconds]" ,
       color="Algorithms: ",
       title="Time comparison of selected algorithms"
      #, subtitle = "using microbenchmark package from R"
      )

p1

#ggsave("fig_times_rNa_mM.pdf",p1,device="pdf", dpi=600, width = 8, height = 8/1.618)



